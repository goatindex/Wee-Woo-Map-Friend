# Error Handling Patterns

> **Comprehensive error handling, recovery strategies, and robust application development**

## üìã Overview

WeeWoo Map Friend implements sophisticated error handling patterns to ensure graceful degradation and robust user experience across all failure scenarios. This document covers error types, recovery strategies, and implementation patterns.

### **Error Handling Principles**

| Principle | Implementation | Status |
|-----------|----------------|---------|
| **Graceful Degradation** | Continue operation with reduced functionality | ‚úÖ Active |
| **User-Friendly Messages** | Clear, actionable error messages | ‚úÖ Active |
| **Automatic Recovery** | Self-healing where possible | ‚úÖ Active |
| **Comprehensive Logging** | Detailed error tracking for debugging | ‚úÖ Active |
| **Fallback Strategies** | Multiple fallback options for critical functions | ‚úÖ Active |
| **Progressive Enhancement** | Core functionality works even with errors | ‚úÖ Active |

## üö® Error Categories

### **1. Network Errors**

Network-related failures with automatic retry and fallback strategies:

```javascript
/**
 * Network error handling with exponential backoff
 */
class NetworkErrorHandler {
  constructor() {\n    this.retryConfig = {\n      maxRetries: 3,\n      baseDelay: 1000, // 1 second\n      maxDelay: 10000, // 10 seconds\n      backoffFactor: 2\n    };\n  }\n  \n  async fetchWithRetry(url, options = {}, retryCount = 0) {\n    try {\n      const response = await fetch(url, {\n        timeout: 10000, // 10 second timeout\n        ...options\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      return response;\n    } catch (error) {\n      console.warn(`Network request failed (attempt ${retryCount + 1}):`, error.message);\n      \n      // Check if we should retry\n      if (this.shouldRetry(error, retryCount)) {\n        const delay = this.calculateDelay(retryCount);\n        \n        console.log(`Retrying in ${delay}ms...`);\n        await this.delay(delay);\n        \n        return this.fetchWithRetry(url, options, retryCount + 1);\n      }\n      \n      // No more retries, handle error\n      throw this.enhanceError(error, url, retryCount);\n    }\n  }\n  \n  shouldRetry(error, retryCount) {\n    if (retryCount >= this.retryConfig.maxRetries) {\n      return false;\n    }\n    \n    // Don't retry on client errors (4xx)\n    if (error.message.includes('HTTP 4')) {\n      return false;\n    }\n    \n    // Retry on network errors and server errors (5xx)\n    return (\n      error.name === 'TypeError' || // Network error\n      error.name === 'TimeoutError' ||\n      error.message.includes('HTTP 5') // Server error\n    );\n  }\n  \n  calculateDelay(retryCount) {\n    const delay = this.retryConfig.baseDelay * \n      Math.pow(this.retryConfig.backoffFactor, retryCount);\n    \n    return Math.min(delay, this.retryConfig.maxDelay);\n  }\n  \n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  enhanceError(originalError, url, retryCount) {\n    const enhancedError = new Error(\n      `Failed to fetch ${url} after ${retryCount + 1} attempts: ${originalError.message}`\n    );\n    \n    enhancedError.originalError = originalError;\n    enhancedError.url = url;\n    enhancedError.retryCount = retryCount;\n    enhancedError.type = 'NetworkError';\n    \n    return enhancedError;\n  }\n}\n\n// Global network error handler instance\nconst networkErrorHandler = new NetworkErrorHandler();\nwindow.networkErrorHandler = networkErrorHandler;\n```\n\n### **2. Data Loading Errors**\n\nRobust data loading with fallback strategies:\n\n```javascript\n/**\n * Enhanced data loading with comprehensive error handling\n */\nconst loadPolygonCategoryWithErrorHandling = async (category, url) => {\n  const meta = window.categoryMeta[category];\n  const map = window.getMap();\n  \n  try {\n    // Check offline status\n    if (window.isOffline()) {\n      return handleOfflineDataLoading(category, url);\n    }\n    \n    console.log(`Loading ${category} data from ${url}`);\n    \n    // Attempt to load with retry logic\n    const response = await networkErrorHandler.fetchWithRetry(url);\n    const geojson = await response.json();\n    \n    // Validate data structure\n    if (!validateGeoJSONData(geojson, category)) {\n      throw new Error(`Invalid GeoJSON data for ${category}`);\n    }\n    \n    // Process data\n    const processedFeatures = await processGeoJSONData(geojson, category, meta);\n    \n    // Update UI\n    updateSidebarForCategory(category, processedFeatures);\n    \n    console.log(`‚úì Successfully loaded ${processedFeatures.length} ${category} features`);\n    \n    return {\n      success: true,\n      category,\n      featuresLoaded: processedFeatures.length,\n      source: 'network'\n    };\n    \n  } catch (error) {\n    console.error(`Error loading ${category} data:`, error);\n    \n    // Try fallback strategies\n    return handleDataLoadingError(category, url, error);\n  }\n};\n\nconst handleDataLoadingError = async (category, url, error) => {\n  const errorHandlers = [\n    () => loadFromCache(category, url),\n    () => loadMockData(category),\n    () => showGracefulDegradation(category, error)\n  ];\n  \n  for (const handler of errorHandlers) {\n    try {\n      const result = await handler();\n      if (result.success) {\n        return result;\n      }\n    } catch (fallbackError) {\n      console.warn(`Fallback failed for ${category}:`, fallbackError.message);\n    }\n  }\n  \n  // All fallbacks failed\n  return {\n    success: false,\n    category,\n    error: error.message,\n    fallbacksAttempted: errorHandlers.length\n  };\n};\n\nconst loadFromCache = async (category, url) => {\n  if (!('caches' in window)) {\n    throw new Error('Cache API not supported');\n  }\n  \n  try {\n    const cache = await caches.open('weewoo-runtime-v1.0');\n    const cachedResponse = await cache.match(url);\n    \n    if (!cachedResponse) {\n      throw new Error('No cached data available');\n    }\n    \n    const geojson = await cachedResponse.json();\n    const processedFeatures = await processGeoJSONData(geojson, category, window.categoryMeta[category]);\n    \n    updateSidebarForCategory(category, processedFeatures);\n    \n    // Show cache indicator\n    showCacheIndicator(category);\n    \n    console.log(`‚úì Loaded ${category} from cache (${processedFeatures.length} features)`);\n    \n    return {\n      success: true,\n      category,\n      featuresLoaded: processedFeatures.length,\n      source: 'cache'\n    };\n  } catch (cacheError) {\n    throw new Error(`Cache loading failed: ${cacheError.message}`);\n  }\n};\n\nconst loadMockData = async (category) => {\n  // Generate minimal mock data for testing/development\n  const mockData = generateMockData(category);\n  \n  if (mockData.features.length === 0) {\n    throw new Error('No mock data available');\n  }\n  \n  const processedFeatures = await processGeoJSONData(mockData, category, window.categoryMeta[category]);\n  updateSidebarForCategory(category, processedFeatures);\n  \n  // Show mock data indicator\n  showMockDataIndicator(category);\n  \n  console.log(`‚úì Loaded ${category} mock data (${processedFeatures.length} features)`);\n  \n  return {\n    success: true,\n    category,\n    featuresLoaded: processedFeatures.length,\n    source: 'mock'\n  };\n};\n\nconst showGracefulDegradation = async (category, error) => {\n  // Show error message but don't break the app\n  const errorMessage = getUserFriendlyErrorMessage(category, error);\n  window.showSidebarError(errorMessage);\n  \n  // Log detailed error for debugging\n  logErrorToMonitoring({\n    type: 'DataLoadingError',\n    category,\n    error: error.message,\n    stack: error.stack,\n    timestamp: new Date().toISOString(),\n    userAgent: navigator.userAgent,\n    url: window.location.href\n  });\n  \n  return {\n    success: false,\n    category,\n    error: errorMessage,\n    gracefulDegradation: true\n  };\n};\n```\n\n### **3. Weather API Errors**\n\nWeather service error handling with provider fallback:\n\n```javascript\n/**\n * Weather API error handling with automatic provider fallback\n */\nclass WeatherErrorHandler {\n  constructor() {\n    this.providers = ['willyweather', 'open-meteo', 'mock'];\n    this.providerErrors = new Map();\n  }\n  \n  async getWeatherWithFallback(lat, lon, preferredProvider = 'willyweather') {\n    // Validate coordinates first\n    if (!this.validateCoordinates(lat, lon)) {\n      throw new Error('Invalid coordinates provided');\n    }\n    \n    // Try preferred provider first\n    const providers = [preferredProvider, ...this.providers.filter(p => p !== preferredProvider)];\n    \n    for (const provider of providers) {\n      try {\n        console.log(`Attempting weather request with ${provider}`);\n        \n        const weatherData = await this.fetchWeatherFromProvider(lat, lon, provider);\n        \n        // Clear any previous errors for this provider\n        this.providerErrors.delete(provider);\n        \n        return {\n          success: true,\n          data: weatherData,\n          provider,\n          coordinates: { lat, lon }\n        };\n        \n      } catch (error) {\n        console.warn(`Weather provider ${provider} failed:`, error.message);\n        \n        // Store error for this provider\n        this.providerErrors.set(provider, {\n          error: error.message,\n          timestamp: Date.now()\n        });\n        \n        // Continue to next provider\n        continue;\n      }\n    }\n    \n    // All providers failed\n    throw new Error(this.createComprehensiveErrorMessage());\n  }\n  \n  validateCoordinates(lat, lon) {\n    const latitude = parseFloat(lat);\n    const longitude = parseFloat(lon);\n    \n    return (\n      !isNaN(latitude) && latitude >= -90 && latitude <= 90 &&\n      !isNaN(longitude) && longitude >= -180 && longitude <= 180\n    );\n  }\n  \n  async fetchWeatherFromProvider(lat, lon, provider) {\n    const backendBase = this.getBackendURL();\n    const url = `${backendBase}/api/weather?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&provider=${encodeURIComponent(provider)}`;\n    \n    const response = await networkErrorHandler.fetchWithRetry(url, {\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    const data = await response.json();\n    \n    // Validate response structure\n    if (!this.validateWeatherData(data)) {\n      throw new Error(`Invalid weather data from ${provider}`);\n    }\n    \n    return data;\n  }\n  \n  validateWeatherData(data) {\n    return (\n      data &&\n      typeof data === 'object' &&\n      data.location &&\n      data.forecast &&\n      Array.isArray(data.forecast) &&\n      data.forecast.length > 0\n    );\n  }\n  \n  getBackendURL() {\n    const isDevelopment = location.hostname === 'localhost' || \n                         location.hostname === '127.0.0.1';\n    \n    return isDevelopment ? 'http://127.0.0.1:5000' : '';\n  }\n  \n  createComprehensiveErrorMessage() {\n    const errors = Array.from(this.providerErrors.entries())\n      .map(([provider, errorInfo]) => `${provider}: ${errorInfo.error}`)\n      .join('; ');\n    \n    return `All weather providers failed. Errors: ${errors}`;\n  }\n  \n  getProviderStatus() {\n    const status = {};\n    \n    this.providers.forEach(provider => {\n      const error = this.providerErrors.get(provider);\n      status[provider] = {\n        available: !error,\n        lastError: error ? error.error : null,\n        lastErrorTime: error ? new Date(error.timestamp).toISOString() : null\n      };\n    });\n    \n    return status;\n  }\n}\n\n// Global weather error handler\nconst weatherErrorHandler = new WeatherErrorHandler();\nwindow.weatherErrorHandler = weatherErrorHandler;\n```\n\n### **4. UI and State Errors**\n\nRobust UI error handling and state recovery:\n\n```javascript\n/**\n * UI error handling and state recovery\n */\nclass UIErrorHandler {\n  constructor() {\n    this.stateBackups = new Map();\n    this.errorCallbacks = new Map();\n    this.setupGlobalErrorHandling();\n  }\n  \n  setupGlobalErrorHandling() {\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      console.error('Unhandled promise rejection:', event.reason);\n      \n      this.handleGenericError({\n        type: 'UnhandledPromiseRejection',\n        error: event.reason,\n        stack: event.reason?.stack\n      });\n      \n      // Prevent console spam\n      event.preventDefault();\n    });\n    \n    // Handle JavaScript errors\n    window.addEventListener('error', (event) => {\n      console.error('JavaScript error:', event.error);\n      \n      this.handleGenericError({\n        type: 'JavaScriptError',\n        error: event.error,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno\n      });\n    });\n  }\n  \n  wrapFunction(fn, errorHandler, context = null) {\n    return async (...args) => {\n      try {\n        // Backup state before operation\n        if (context) {\n          this.backupState(context);\n        }\n        \n        return await fn.apply(this, args);\n      } catch (error) {\n        console.error(`Function ${fn.name} failed:`, error);\n        \n        // Try to recover state\n        if (context) {\n          this.restoreState(context);\n        }\n        \n        // Call custom error handler if provided\n        if (errorHandler) {\n          try {\n            return await errorHandler(error, args);\n          } catch (handlerError) {\n            console.error('Error handler also failed:', handlerError);\n          }\n        }\n        \n        // Fallback to generic error handling\n        this.handleGenericError({\n          type: 'FunctionError',\n          function: fn.name,\n          error,\n          arguments: args\n        });\n        \n        throw error;\n      }\n    };\n  }\n  \n  backupState(contextName) {\n    try {\n      const stateBackup = {\n        featureLayers: JSON.parse(JSON.stringify(window.featureLayers || {})),\n        emphasised: JSON.parse(JSON.stringify(window.emphasised || {})),\n        activeListFilter: window.activeListFilter || '',\n        timestamp: Date.now()\n      };\n      \n      this.stateBackups.set(contextName, stateBackup);\n      console.log(`State backed up for context: ${contextName}`);\n    } catch (error) {\n      console.warn('Failed to backup state:', error);\n    }\n  }\n  \n  restoreState(contextName) {\n    try {\n      const backup = this.stateBackups.get(contextName);\n      \n      if (!backup) {\n        console.warn(`No backup found for context: ${contextName}`);\n        return false;\n      }\n      \n      // Restore state objects\n      if (backup.featureLayers) {\n        window.featureLayers = backup.featureLayers;\n      }\n      \n      if (backup.emphasised) {\n        window.emphasised = backup.emphasised;\n      }\n      \n      if (backup.activeListFilter !== undefined) {\n        window.activeListFilter = backup.activeListFilter;\n      }\n      \n      // Update UI to reflect restored state\n      if (typeof window.updateActiveList === 'function') {\n        window.updateActiveList();\n      }\n      \n      console.log(`State restored from backup: ${contextName}`);\n      return true;\n    } catch (error) {\n      console.error('Failed to restore state:', error);\n      return false;\n    }\n  }\n  \n  handleGenericError(errorInfo) {\n    // Log error for debugging\n    logErrorToMonitoring({\n      ...errorInfo,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    });\n    \n    // Show user-friendly message\n    const userMessage = this.getUserFriendlyMessage(errorInfo);\n    this.showErrorToUser(userMessage);\n    \n    // Try automatic recovery\n    this.attemptAutomaticRecovery(errorInfo);\n  }\n  \n  getUserFriendlyMessage(errorInfo) {\n    const messageMap = {\n      'NetworkError': 'Connection problem. Please check your internet connection and try again.',\n      'DataLoadingError': 'Unable to load map data. Some features may not be available.',\n      'UnhandledPromiseRejection': 'Something went wrong. Please refresh the page if problems persist.',\n      'JavaScriptError': 'An unexpected error occurred. Please refresh the page.',\n      'FunctionError': 'A feature is temporarily unavailable. Please try again.'\n    };\n    \n    return messageMap[errorInfo.type] || 'An unexpected error occurred. Please refresh the page if problems persist.';\n  }\n  \n  showErrorToUser(message) {\n    // Use existing error UI if available\n    if (typeof window.showSidebarError === 'function') {\n      window.showSidebarError(message);\n    } else {\n      // Fallback to simple alert\n      console.error('User message:', message);\n      \n      // Create simple error banner\n      this.createErrorBanner(message);\n    }\n  }\n  \n  createErrorBanner(message) {\n    // Remove existing error banner\n    const existingBanner = document.getElementById('error-banner');\n    if (existingBanner) {\n      existingBanner.remove();\n    }\n    \n    // Create new error banner\n    const banner = document.createElement('div');\n    banner.id = 'error-banner';\n    banner.className = 'error-banner';\n    banner.innerHTML = `\n      <div class=\"error-content\">\n        <span class=\"error-icon\">‚ö†Ô∏è</span>\n        <span class=\"error-message\">${message}</span>\n        <button class=\"error-dismiss\" onclick=\"this.parentElement.parentElement.remove()\">√ó</button>\n      </div>\n    `;\n    \n    // Add basic styling\n    banner.style.cssText = `\n      position: fixed;\n      top: 10px;\n      left: 50%;\n      transform: translateX(-50%);\n      background: #f44336;\n      color: white;\n      padding: 12px 20px;\n      border-radius: 6px;\n      box-shadow: 0 2px 10px rgba(0,0,0,0.2);\n      z-index: 10000;\n      max-width: 90vw;\n      font-family: Arial, sans-serif;\n    `;\n    \n    document.body.appendChild(banner);\n    \n    // Auto-dismiss after 10 seconds\n    setTimeout(() => {\n      if (banner.parentElement) {\n        banner.remove();\n      }\n    }, 10000);\n  }\n  \n  attemptAutomaticRecovery(errorInfo) {\n    switch (errorInfo.type) {\n      case 'NetworkError':\n        // Retry network operations after delay\n        setTimeout(() => {\n          if (navigator.onLine) {\n            console.log('Network recovered, attempting to reload data');\n            this.retryFailedOperations();\n          }\n        }, 5000);\n        break;\n        \n      case 'DataLoadingError':\n        // Try to load critical data only\n        console.log('Attempting to load critical data only');\n        this.loadCriticalDataOnly();\n        break;\n        \n      case 'JavaScriptError':\n        // Reset to safe state\n        console.log('Resetting to safe state');\n        this.resetToSafeState();\n        break;\n    }\n  }\n  \n  async retryFailedOperations() {\n    // Implementation depends on tracked failed operations\n    console.log('Retrying failed operations...');\n  }\n  \n  async loadCriticalDataOnly() {\n    try {\n      // Load only essential services\n      await window.loadAmbulance();\n      await window.loadPolice();\n      console.log('Critical data loaded successfully');\n    } catch (error) {\n      console.error('Failed to load critical data:', error);\n    }\n  }\n  \n  resetToSafeState() {\n    try {\n      // Clear potentially corrupted state\n      if (window.featureLayers) {\n        Object.keys(window.featureLayers).forEach(category => {\n          window.featureLayers[category] = {};\n        });\n      }\n      \n      if (window.emphasised) {\n        Object.keys(window.emphasised).forEach(category => {\n          window.emphasised[category] = {};\n        });\n      }\n      \n      // Reset UI\n      if (typeof window.updateActiveList === 'function') {\n        window.updateActiveList();\n      }\n      \n      console.log('Application reset to safe state');\n    } catch (error) {\n      console.error('Failed to reset to safe state:', error);\n    }\n  }\n}\n\n// Global UI error handler\nconst uiErrorHandler = new UIErrorHandler();\nwindow.uiErrorHandler = uiErrorHandler;\n```\n\n## üîß Error Recovery Strategies\n\n### **Automatic Recovery**\n\n```javascript\n/**\n * Automatic error recovery system\n */\nclass AutoRecoverySystem {\n  constructor() {\n    this.recoveryStrategies = new Map();\n    this.recoveryHistory = [];\n    this.setupRecoveryStrategies();\n  }\n  \n  setupRecoveryStrategies() {\n    // Data loading recovery\n    this.recoveryStrategies.set('data-loading', {\n      attempts: 3,\n      strategy: async (context) => {\n        const { category, url } = context;\n        \n        // Try cache first\n        try {\n          return await loadFromCache(category, url);\n        } catch {\n          // Try mock data\n          return await loadMockData(category);\n        }\n      }\n    });\n    \n    // Weather service recovery\n    this.recoveryStrategies.set('weather-service', {\n      attempts: 2,\n      strategy: async (context) => {\n        const { lat, lon, failedProvider } = context;\n        \n        // Try alternative providers\n        const providers = ['open-meteo', 'mock'].filter(p => p !== failedProvider);\n        \n        for (const provider of providers) {\n          try {\n            return await weatherErrorHandler.fetchWeatherFromProvider(lat, lon, provider);\n          } catch {\n            continue;\n          }\n        }\n        \n        throw new Error('All weather providers failed');\n      }\n    });\n    \n    // UI state recovery\n    this.recoveryStrategies.set('ui-state', {\n      attempts: 1,\n      strategy: async (context) => {\n        // Reset UI to default state\n        return this.resetUIToDefault();\n      }\n    });\n  }\n  \n  async attemptRecovery(errorType, context, maxAttempts = null) {\n    const strategy = this.recoveryStrategies.get(errorType);\n    \n    if (!strategy) {\n      throw new Error(`No recovery strategy for error type: ${errorType}`);\n    }\n    \n    const attempts = maxAttempts || strategy.attempts;\n    \n    for (let attempt = 1; attempt <= attempts; attempt++) {\n      try {\n        console.log(`Recovery attempt ${attempt}/${attempts} for ${errorType}`);\n        \n        const result = await strategy.strategy(context);\n        \n        // Record successful recovery\n        this.recordRecovery(errorType, attempt, true);\n        \n        return result;\n      } catch (error) {\n        console.warn(`Recovery attempt ${attempt} failed:`, error.message);\n        \n        if (attempt === attempts) {\n          // Record failed recovery\n          this.recordRecovery(errorType, attempt, false);\n          throw error;\n        }\n        \n        // Wait before next attempt\n        await this.delay(1000 * attempt);\n      }\n    }\n  }\n  \n  recordRecovery(errorType, attempts, successful) {\n    const record = {\n      errorType,\n      attempts,\n      successful,\n      timestamp: Date.now()\n    };\n    \n    this.recoveryHistory.push(record);\n    \n    // Keep only last 100 records\n    if (this.recoveryHistory.length > 100) {\n      this.recoveryHistory = this.recoveryHistory.slice(-100);\n    }\n    \n    console.log(`Recovery ${successful ? 'succeeded' : 'failed'} for ${errorType} after ${attempts} attempts`);\n  }\n  \n  resetUIToDefault() {\n    try {\n      // Reset sidebar state\n      const sidebar = document.querySelector('.sidebar');\n      if (sidebar) {\n        sidebar.classList.remove('open');\n      }\n      \n      // Clear active list filter\n      window.activeListFilter = '';\n      \n      // Reset all emphasis\n      Object.keys(window.emphasised || {}).forEach(category => {\n        Object.keys(window.emphasised[category] || {}).forEach(key => {\n          window.emphasised[category][key] = false;\n        });\n      });\n      \n      // Update UI\n      if (typeof window.updateActiveList === 'function') {\n        window.updateActiveList();\n      }\n      \n      return { success: true, action: 'UI reset to default state' };\n    } catch (error) {\n      throw new Error(`Failed to reset UI: ${error.message}`);\n    }\n  }\n  \n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  getRecoveryStats() {\n    const stats = {\n      totalRecoveries: this.recoveryHistory.length,\n      successfulRecoveries: this.recoveryHistory.filter(r => r.successful).length,\n      errorTypes: {}\n    };\n    \n    // Group by error type\n    this.recoveryHistory.forEach(record => {\n      if (!stats.errorTypes[record.errorType]) {\n        stats.errorTypes[record.errorType] = {\n          total: 0,\n          successful: 0,\n          averageAttempts: 0\n        };\n      }\n      \n      const typeStats = stats.errorTypes[record.errorType];\n      typeStats.total++;\n      \n      if (record.successful) {\n        typeStats.successful++;\n      }\n      \n      typeStats.averageAttempts = \n        (typeStats.averageAttempts * (typeStats.total - 1) + record.attempts) / typeStats.total;\n    });\n    \n    return stats;\n  }\n}\n\n// Global auto-recovery system\nconst autoRecoverySystem = new AutoRecoverySystem();\nwindow.autoRecoverySystem = autoRecoverySystem;\n```\n\n## üìä Error Monitoring & Logging\n\n### **Comprehensive Error Logging**\n\n```javascript\n/**\n * Error monitoring and logging system\n */\nclass ErrorMonitor {\n  constructor() {\n    this.errorQueue = [];\n    this.errorCounts = new Map();\n    this.setupPeriodicReporting();\n  }\n  \n  logError(errorInfo) {\n    // Enhance error with context\n    const enhancedError = {\n      ...errorInfo,\n      id: this.generateErrorId(),\n      timestamp: new Date().toISOString(),\n      sessionId: this.getSessionId(),\n      userId: this.getUserId(),\n      device: this.getDeviceInfo(),\n      performance: this.getPerformanceSnapshot(),\n      state: this.getApplicationState()\n    };\n    \n    // Add to queue\n    this.errorQueue.push(enhancedError);\n    \n    // Update error counts\n    const errorKey = `${errorInfo.type}-${errorInfo.category || 'unknown'}`;\n    this.errorCounts.set(errorKey, (this.errorCounts.get(errorKey) || 0) + 1);\n    \n    // Send to monitoring service (if in production)\n    if (!this.isDevelopment()) {\n      this.sendToMonitoring(enhancedError);\n    } else {\n      console.group('üêõ Error Logged');\n      console.error('Error:', enhancedError);\n      console.groupEnd();\n    }\n    \n    // Keep queue size manageable\n    if (this.errorQueue.length > 100) {\n      this.errorQueue = this.errorQueue.slice(-100);\n    }\n  }\n  \n  generateErrorId() {\n    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  getSessionId() {\n    if (!this.sessionId) {\n      this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    return this.sessionId;\n  }\n  \n  getUserId() {\n    // Anonymous user ID for tracking patterns\n    if (!this.userId) {\n      this.userId = localStorage.getItem('anonymousUserId') || \n        `user_${Math.random().toString(36).substr(2, 16)}`;\n      localStorage.setItem('anonymousUserId', this.userId);\n    }\n    return this.userId;\n  }\n  \n  getDeviceInfo() {\n    return {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      cookieEnabled: navigator.cookieEnabled,\n      onLine: navigator.onLine,\n      screen: {\n        width: screen.width,\n        height: screen.height,\n        colorDepth: screen.colorDepth\n      },\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight\n      }\n    };\n  }\n  \n  getPerformanceSnapshot() {\n    if (!('performance' in window)) {\n      return null;\n    }\n    \n    return {\n      navigationStart: performance.timeOrigin,\n      now: performance.now(),\n      memory: performance.memory ? {\n        used: performance.memory.usedJSHeapSize,\n        total: performance.memory.totalJSHeapSize,\n        limit: performance.memory.jsHeapSizeLimit\n      } : null\n    };\n  }\n  \n  getApplicationState() {\n    return {\n      categoriesLoaded: Object.keys(window.featureLayers || {}),\n      activeFeatures: this.countActiveFeatures(),\n      emphasizedFeatures: this.countEmphasizedFeatures(),\n      activeListFilter: window.activeListFilter || '',\n      offline: window.isOffline ? window.isOffline() : !navigator.onLine\n    };\n  }\n  \n  countActiveFeatures() {\n    const counts = {};\n    Object.keys(window.featureLayers || {}).forEach(category => {\n      counts[category] = Object.keys(window.featureLayers[category] || {}).length;\n    });\n    return counts;\n  }\n  \n  countEmphasizedFeatures() {\n    const counts = {};\n    Object.keys(window.emphasised || {}).forEach(category => {\n      const emphasized = Object.values(window.emphasised[category] || {})\n        .filter(Boolean).length;\n      counts[category] = emphasized;\n    });\n    return counts;\n  }\n  \n  async sendToMonitoring(errorInfo) {\n    try {\n      // In a real application, send to your monitoring service\n      // e.g., Sentry, LogRocket, or custom endpoint\n      \n      const response = await fetch('/api/errors', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(errorInfo)\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to send error to monitoring: ${response.status}`);\n      }\n    } catch (monitoringError) {\n      console.warn('Failed to send error to monitoring service:', monitoringError);\n      \n      // Store for later retry\n      this.storeErrorForRetry(errorInfo);\n    }\n  }\n  \n  storeErrorForRetry(errorInfo) {\n    try {\n      const stored = JSON.parse(localStorage.getItem('pendingErrors') || '[]');\n      stored.push(errorInfo);\n      \n      // Keep only last 50 errors in storage\n      const limited = stored.slice(-50);\n      localStorage.setItem('pendingErrors', JSON.stringify(limited));\n    } catch (storageError) {\n      console.warn('Failed to store error for retry:', storageError);\n    }\n  }\n  \n  setupPeriodicReporting() {\n    // Send error summary every 5 minutes\n    setInterval(() => {\n      this.sendErrorSummary();\n    }, 5 * 60 * 1000);\n  }\n  \n  sendErrorSummary() {\n    if (this.errorCounts.size === 0) return;\n    \n    const summary = {\n      type: 'ErrorSummary',\n      timeWindow: '5min',\n      timestamp: new Date().toISOString(),\n      sessionId: this.getSessionId(),\n      errorCounts: Object.fromEntries(this.errorCounts)\n    };\n    \n    console.log('Error summary:', summary);\n    \n    // Reset counts\n    this.errorCounts.clear();\n  }\n  \n  isDevelopment() {\n    return location.hostname === 'localhost' || \n           location.hostname === '127.0.0.1' ||\n           location.protocol === 'file:';\n  }\n  \n  getErrorReport() {\n    return {\n      recentErrors: this.errorQueue.slice(-20),\n      errorCounts: Object.fromEntries(this.errorCounts),\n      sessionInfo: {\n        sessionId: this.getSessionId(),\n        userId: this.getUserId(),\n        startTime: this.sessionStartTime || 'unknown'\n      }\n    };\n  }\n}\n\n// Global error monitor\nconst errorMonitor = new ErrorMonitor();\nwindow.errorMonitor = errorMonitor;\n\n// Helper function for easy error logging\nwindow.logErrorToMonitoring = (errorInfo) => {\n  errorMonitor.logError(errorInfo);\n};\n```\n\n## üîó Integration Examples\n\n### **Complete Error Handling Setup**\n\n```javascript\n/**\n * Initialize comprehensive error handling\n */\nconst initializeErrorHandling = () => {\n  console.log('üõ°Ô∏è Initializing error handling system...');\n  \n  // Wrap critical functions with error handling\n  if (window.loadPolygonCategory) {\n    window.loadPolygonCategory = uiErrorHandler.wrapFunction(\n      window.loadPolygonCategory,\n      async (error, args) => {\n        const [category, url] = args;\n        console.log(`Attempting recovery for ${category} data loading`);\n        \n        return autoRecoverySystem.attemptRecovery('data-loading', {\n          category,\n          url,\n          error: error.message\n        });\n      },\n      'data-loading'\n    );\n  }\n  \n  // Set up error boundaries for UI components\n  setupErrorBoundaries();\n  \n  // Initialize monitoring\n  errorMonitor.sessionStartTime = Date.now();\n  \n  console.log('‚úÖ Error handling initialized');\n};\n\nconst setupErrorBoundaries = () => {\n  // Wrap updateActiveList with error handling\n  if (window.updateActiveList) {\n    const originalUpdateActiveList = window.updateActiveList;\n    \n    window.updateActiveList = uiErrorHandler.wrapFunction(\n      originalUpdateActiveList,\n      async (error) => {\n        console.log('Attempting UI state recovery');\n        \n        return autoRecoverySystem.attemptRecovery('ui-state', {\n          operation: 'updateActiveList',\n          error: error.message\n        });\n      },\n      'ui-update'\n    );\n  }\n};\n\n// Auto-initialize error handling\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeErrorHandling);\n} else {\n  initializeErrorHandling();\n}\n```\n\n## üîó Related Documentation\n\n- **[API Overview](README.md)** - Complete API reference\n- **[Examples](examples.md)** - Error handling in practice\n- **[Authentication](authentication.md)** - Security-related error handling\n- **[Rate Limits](rate-limits.md)** - Performance and constraint errors\n\n---\n\n**Next**: Learn about [geocoding utilities and data preparation](geocoding.md) for enhanced location services.