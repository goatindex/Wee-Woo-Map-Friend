# Geocoding & Location Services

> **Address search, coordinate conversion, and location enhancement utilities**

## ðŸ“‹ Overview

WeeWoo Map Friend includes geocoding utilities primarily for data preparation and enhancement. While the main application focuses on emergency services mapping, geocoding capabilities support data preparation scripts and potential future location search features.

### **Geocoding Features**

| Feature | Type | Purpose | Status |
|---------|------|---------|--------|
| **Nominatim Integration** | Development | Data preparation for CFA facilities | âœ… Active |
| **Coordinate Conversion** | Runtime | MGA94/UTM to WGS84 conversion | âœ… Active |
| **Address Validation** | Development | Data quality assurance | âœ… Active |
| **Bulk Geocoding** | Scripts | Batch processing for data enhancement | âœ… Active |
| **Rate Limiting** | Development | Respect service limits | âœ… Active |
| **Error Handling** | All | Robust geocoding workflows | âœ… Active |

## ðŸ—ºï¸ Coordinate Systems

### **Supported Coordinate Systems**

WeeWoo Map Friend handles multiple coordinate systems commonly used in Australian geographic data:

```javascript
/**
 * Coordinate system definitions and conversions
 */
const CoordinateSystems = {
  // WGS84 (GPS standard) - Used by Leaflet and web mapping
  WGS84: {\n    name: 'World Geodetic System 1984',\n    epsgCode: 'EPSG:4326',\n    units: 'degrees',\n    bounds: {\n      lat: { min: -90, max: 90 },\n      lon: { min: -180, max: 180 }\n    }\n  },\n  \n  // MGA94 Zone 55 (Melbourne/Victoria)\n  MGA94_55: {\n    name: 'Map Grid of Australia 1994 Zone 55',\n    epsgCode: 'EPSG:28355',\n    units: 'meters',\n    bounds: {\n      easting: { min: 200000, max: 800000 },\n      northing: { min: 5800000, max: 6200000 }\n    }\n  },\n  \n  // MGA94 Zone 54 (Western Victoria)\n  MGA94_54: {\n    name: 'Map Grid of Australia 1994 Zone 54',\n    epsgCode: 'EPSG:28354', \n    units: 'meters',\n    bounds: {\n      easting: { min: 200000, max: 800000 },\n      northing: { min: 5800000, max: 6200000 }\n    }\n  }\n};\n\n/**\n * Detect coordinate system from values\n */\nconst detectCoordinateSystem = (x, y) => {\n  // Check if values are in WGS84 range\n  if (x >= -180 && x <= 180 && y >= -90 && y <= 90) {\n    return 'WGS84';\n  }\n  \n  // Check if values are in MGA94 range\n  if (x > 100000 && x < 1000000 && y > 5000000 && y < 7000000) {\n    // Determine zone based on easting\n    if (x >= 500000) {\n      return 'MGA94_55'; // Zone 55 (eastern Victoria)\n    } else {\n      return 'MGA94_54'; // Zone 54 (western Victoria)\n    }\n  }\n  \n  return 'UNKNOWN';\n};\n\n/**\n * Convert MGA94/UTM coordinates to WGS84 lat/lon\n * This is a simplified conversion - use proj4 for production\n */\nwindow.convertMGA94ToLatLon = function(easting, northing, zone = 55) {\n  // Simplified conversion for demonstration\n  // In production, use proj4.js or similar library\n  \n  try {\n    // Basic validation\n    if (easting < 100000 || easting > 1000000) {\n      throw new Error('Invalid easting value');\n    }\n    \n    if (northing < 5000000 || northing > 7000000) {\n      throw new Error('Invalid northing value');\n    }\n    \n    // Approximate conversion for Victoria region\n    // This is NOT accurate for production use!\n    const centralMeridian = zone === 55 ? 147 : 141;\n    const falseEasting = 500000;\n    const falseNorthing = 10000000;\n    \n    // Very rough approximation\n    const deltaEasting = easting - falseEasting;\n    const deltaNorthing = northing - falseNorthing;\n    \n    const lat = -37.8 + (deltaNorthing / 111000);\n    const lon = centralMeridian + (deltaEasting / (111000 * Math.cos(lat * Math.PI / 180)));\n    \n    // Validate result is within Victoria bounds\n    if (lat < -39.5 || lat > -33.5 || lon < 140.5 || lon > 150.5) {\n      throw new Error('Converted coordinates outside Victoria bounds');\n    }\n    \n    return { lat, lng: lon };\n  } catch (error) {\n    console.error('Coordinate conversion failed:', error);\n    throw error;\n  }\n};\n\n/**\n * Proper coordinate conversion using proj4 (when available)\n */\nconst convertCoordinatesProj4 = (x, y, fromProj, toProj) => {\n  if (typeof proj4 === 'undefined') {\n    console.warn('proj4 not available, using simplified conversion');\n    return window.convertMGA94ToLatLon(x, y);\n  }\n  \n  try {\n    // Define projections\n    const from = proj4(fromProj);\n    const to = proj4(toProj);\n    \n    // Convert coordinates\n    const result = proj4(from, to, [x, y]);\n    \n    return {\n      lat: result[1],\n      lng: result[0]\n    };\n  } catch (error) {\n    console.error('proj4 conversion failed:', error);\n    throw error;\n  }\n};\n```\n\n## ðŸ” Nominatim Geocoding\n\n### **Development Geocoding Service**\n\nUsed primarily for data preparation scripts to enhance CFA facility data:\n\n```python\n# Python geocoding script for data preparation\nimport asyncio\nimport httpx\nimport time\nfrom typing import Optional, Tuple\n\nclass NominatimGeocoder:\n    \"\"\"\n    Nominatim geocoding service for data preparation.\n    Respects rate limits and includes error handling.\n    \"\"\"\n    \n    def __init__(self):\n        self.base_url = \"https://nominatim.openstreetmap.org/search\"\n        self.last_request_time = 0\n        self.rate_limit_delay = 1.0  # 1 second between requests\n        self.user_agent = \"WeeWoo-Map-Friend/1.0 (development@example.com)\"\n        self.timeout = 10\n        self.retry_attempts = 3\n    \n    async def geocode_address(self, address: str, suburb: str, \n                             state: str = \"Victoria\", \n                             country: str = \"Australia\") -> Optional[Tuple[float, float]]:\n        \"\"\"\n        Geocode an address using Nominatim API.\n        \n        Args:\n            address: Street address\n            suburb: Suburb/locality\n            state: State/territory\n            country: Country\n            \n        Returns:\n            Tuple of (latitude, longitude) or None if geocoding fails\n        \"\"\"\n        \n        # Clean and format address\n        clean_address = self._clean_address(address)\n        query = f\"{clean_address}, {suburb}, {state}, {country}\"\n        \n        for attempt in range(self.retry_attempts):\n            try:\n                # Enforce rate limit\n                await self._enforce_rate_limit()\n                \n                # Build request parameters\n                params = {\n                    'q': query,\n                    'format': 'json',\n                    'limit': 1,\n                    'countrycodes': 'au',\n                    'bounded': 1,\n                    'viewbox': '140.5,-39.5,150.5,-33.5',  # Victoria bounds\n                    'addressdetails': 1\n                }\n                \n                headers = {\n                    'User-Agent': self.user_agent\n                }\n                \n                # Make request\n                async with httpx.AsyncClient() as client:\n                    response = await client.get(\n                        self.base_url,\n                        params=params,\n                        headers=headers,\n                        timeout=self.timeout\n                    )\n                \n                response.raise_for_status()\n                data = response.json()\n                \n                if data and len(data) > 0:\n                    result = data[0]\n                    lat = float(result['lat'])\n                    lon = float(result['lon'])\n                    \n                    # Validate coordinates are in Victoria\n                    if self._validate_victoria_coordinates(lat, lon):\n                        return (lat, lon)\n                    else:\n                        raise ValueError(f\"Coordinates outside Victoria: {lat}, {lon}\")\n                else:\n                    raise ValueError(\"No geocoding results found\")\n                    \n            except Exception as e:\n                print(f\"Geocoding attempt {attempt + 1} failed for '{query}': {e}\")\n                \n                if attempt < self.retry_attempts - 1:\n                    # Wait before retry with exponential backoff\n                    await asyncio.sleep(2 ** attempt)\n                else:\n                    print(f\"Failed to geocode after {self.retry_attempts} attempts: {query}\")\n                    return None\n    \n    def _clean_address(self, address: str) -> str:\n        \"\"\"\n        Clean and format address for geocoding.\n        \"\"\"\n        if not address:\n            return \"\"\n        \n        # Remove common prefixes and suffixes\n        cleaned = address.strip()\n        \n        # Remove 'c/o', 'C/O', etc.\n        cleaned = re.sub(r'^c/o\\s+', '', cleaned, flags=re.IGNORECASE)\n        \n        # Standardize street types\n        street_types = {\n            'rd': 'road',\n            'st': 'street', \n            'ave': 'avenue',\n            'dr': 'drive',\n            'ct': 'court',\n            'pl': 'place'\n        }\n        \n        for abbrev, full in street_types.items():\n            pattern = rf'\\b{abbrev}\\b'\n            cleaned = re.sub(pattern, full, cleaned, flags=re.IGNORECASE)\n        \n        return cleaned\n    \n    async def _enforce_rate_limit(self):\n        \"\"\"\n        Enforce rate limiting to respect Nominatim usage policy.\n        \"\"\"\n        current_time = time.time()\n        time_since_last = current_time - self.last_request_time\n        \n        if time_since_last < self.rate_limit_delay:\n            sleep_time = self.rate_limit_delay - time_since_last\n            await asyncio.sleep(sleep_time)\n        \n        self.last_request_time = time.time()\n    \n    def _validate_victoria_coordinates(self, lat: float, lon: float) -> bool:\n        \"\"\"\n        Validate that coordinates are within Victoria bounds.\n        \"\"\"\n        return (\n            -39.5 <= lat <= -33.5 and\n            140.5 <= lon <= 150.5\n        )\n    \n    async def geocode_batch(self, addresses: list) -> dict:\n        \"\"\"\n        Geocode a batch of addresses with progress reporting.\n        \n        Args:\n            addresses: List of tuples (id, address, suburb)\n            \n        Returns:\n            Dictionary mapping id to coordinates or error\n        \"\"\"\n        results = {}\n        total = len(addresses)\n        \n        print(f\"Starting batch geocoding of {total} addresses...\")\n        print(\"This may take several minutes due to rate limiting...\")\n        \n        for i, (addr_id, address, suburb) in enumerate(addresses):\n            try {\n                coords = await self.geocode_address(address, suburb)\n                \n                if coords:\n                    results[addr_id] = {\n                        'latitude': coords[0],\n                        'longitude': coords[1],\n                        'status': 'success'\n                    }\n                    print(f\"    âœ“ {addr_id}: {coords[0]:.6f}, {coords[1]:.6f}\")\n                else:\n                    results[addr_id] = {\n                        'status': 'failed',\n                        'error': 'No geocoding results found'\n                    }\n                    print(f\"    âœ— {addr_id}: Failed to geocode\")\n                \n            } except Exception as e:\n                results[addr_id] = {\n                    'status': 'error',\n                    'error': str(e)\n                }\n                print(f\"    âœ— {addr_id}: Error - {e}\")\n            \n            # Progress reporting\n            if (i + 1) % 10 == 0:\n                progress = ((i + 1) / total) * 100\n                print(f\"Progress: {progress:.1f}% ({i + 1}/{total})\")\n        \n        success_count = sum(1 for r in results.values() if r['status'] == 'success')\n        print(f\"\\nGeocoding complete: {success_count}/{total} successful\")\n        \n        return results\n```\n\n### **JavaScript Geocoding Integration**\n\nFor potential future frontend geocoding features:\n\n```javascript\n/**\n * Frontend geocoding utilities (for future use)\n */\nclass FrontendGeocoder {\n  constructor() {\n    this.baseUrl = 'https://nominatim.openstreetmap.org/search';\n    this.rateLimiter = new Map(); // IP -> last request time\n    this.cache = new Map(); // Query -> cached result\n    this.cacheExpiry = 24 * 60 * 60 * 1000; // 24 hours\n  }\n  \n  async searchAddress(query, options = {}) {\n    const cleanQuery = this.cleanQuery(query);\n    \n    if (!cleanQuery) {\n      throw new Error('Invalid search query');\n    }\n    \n    // Check cache first\n    const cached = this.getCachedResult(cleanQuery);\n    if (cached) {\n      return cached;\n    }\n    \n    // Check rate limit\n    this.checkRateLimit();\n    \n    try {\n      const results = await this.fetchFromNominatim(cleanQuery, options);\n      \n      // Cache results\n      this.cacheResults(cleanQuery, results);\n      \n      return results;\n    } catch (error) {\n      console.error('Geocoding failed:', error);\n      throw error;\n    }\n  }\n  \n  cleanQuery(query) {\n    if (!query || typeof query !== 'string') {\n      return '';\n    }\n    \n    return query\n      .trim()\n      .replace(/[<>\"'&]/g, '') // Remove potentially dangerous characters\n      .substring(0, 200); // Limit length\n  }\n  \n  checkRateLimit() {\n    const now = Date.now();\n    const lastRequest = this.rateLimiter.get('user') || 0;\n    const timeSinceLastRequest = now - lastRequest;\n    \n    if (timeSinceLastRequest < 1000) { // 1 second minimum\n      throw new Error('Rate limit: Please wait before searching again');\n    }\n    \n    this.rateLimiter.set('user', now);\n  }\n  \n  async fetchFromNominatim(query, options) {\n    const params = new URLSearchParams({\n      q: query,\n      format: 'json',\n      limit: options.limit || 5,\n      countrycodes: 'au',\n      bounded: options.bounded ? '1' : '0',\n      viewbox: '140.5,-39.5,150.5,-33.5', // Victoria bounds\n      addressdetails: '1'\n    });\n    \n    const url = `${this.baseUrl}?${params}`;\n    \n    const response = await fetch(url, {\n      headers: {\n        'User-Agent': 'WeeWoo-Map-Friend/1.0'\n      },\n      timeout: 10000\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Geocoding service error: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Filter and format results\n    return this.formatResults(data);\n  }\n  \n  formatResults(rawResults) {\n    return rawResults\n      .filter(result => this.validateResult(result))\n      .map(result => ({\n        name: result.display_name,\n        address: this.extractAddress(result),\n        coordinates: {\n          lat: parseFloat(result.lat),\n          lon: parseFloat(result.lon)\n        },\n        type: result.type,\n        importance: parseFloat(result.importance || 0),\n        boundingBox: this.extractBoundingBox(result)\n      }))\n      .sort((a, b) => b.importance - a.importance); // Sort by importance\n  }\n  \n  validateResult(result) {\n    const lat = parseFloat(result.lat);\n    const lon = parseFloat(result.lon);\n    \n    // Check if coordinates are valid and within Victoria\n    return (\n      !isNaN(lat) && !isNaN(lon) &&\n      lat >= -39.5 && lat <= -33.5 &&\n      lon >= 140.5 && lon <= 150.5\n    );\n  }\n  \n  extractAddress(result) {\n    const address = result.address || {};\n    \n    return {\n      house_number: address.house_number,\n      street: address.road,\n      suburb: address.suburb || address.neighbourhood,\n      city: address.city || address.town,\n      postcode: address.postcode,\n      state: address.state\n    };\n  }\n  \n  extractBoundingBox(result) {\n    if (!result.boundingbox) return null;\n    \n    const [south, north, west, east] = result.boundingbox.map(parseFloat);\n    \n    return {\n      north,\n      south, \n      east,\n      west\n    };\n  }\n  \n  getCachedResult(query) {\n    const cacheKey = query.toLowerCase();\n    const cached = this.cache.get(cacheKey);\n    \n    if (!cached) return null;\n    \n    // Check if cache has expired\n    if (Date.now() - cached.timestamp > this.cacheExpiry) {\n      this.cache.delete(cacheKey);\n      return null;\n    }\n    \n    return cached.data;\n  }\n  \n  cacheResults(query, results) {\n    const cacheKey = query.toLowerCase();\n    \n    this.cache.set(cacheKey, {\n      data: results,\n      timestamp: Date.now()\n    });\n    \n    // Limit cache size\n    if (this.cache.size > 100) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n  }\n  \n  clearCache() {\n    this.cache.clear();\n  }\n}\n\n// Global geocoder instance (for future use)\n// const geocoder = new FrontendGeocoder();\n// window.geocoder = geocoder;\n```\n\n## ðŸ“ Location Enhancement\n\n### **Automatic Coordinate Detection**\n\nAutomatic detection and conversion of coordinate systems in data loading:\n\n```javascript\n/**\n * Enhanced coordinate processing for data loading\n */\nconst processGeoJSONCoordinates = (feature, category) => {\n  if (!feature.geometry || !feature.geometry.coordinates) {\n    return feature; // No coordinates to process\n  }\n  \n  const geometry = feature.geometry;\n  \n  if (geometry.type === 'Point') {\n    geometry.coordinates = processPointCoordinates(geometry.coordinates);\n  } else if (geometry.type === 'Polygon') {\n    geometry.coordinates = geometry.coordinates.map(ring => \n      ring.map(processPointCoordinates)\n    );\n  } else if (geometry.type === 'MultiPolygon') {\n    geometry.coordinates = geometry.coordinates.map(polygon =>\n      polygon.map(ring => ring.map(processPointCoordinates))\n    );\n  }\n  \n  return feature;\n};\n\nconst processPointCoordinates = (coords) => {\n  if (!Array.isArray(coords) || coords.length < 2) {\n    return coords;\n  }\n  \n  const [x, y] = coords;\n  const coordinateSystem = detectCoordinateSystem(x, y);\n  \n  switch (coordinateSystem) {\n    case 'WGS84':\n      // Already in correct format\n      return coords;\n      \n    case 'MGA94_55':\n    case 'MGA94_54':\n      try {\n        // Convert to WGS84\n        const converted = window.convertMGA94ToLatLon(x, y);\n        return [converted.lng, converted.lat]; // GeoJSON order: [lon, lat]\n      } catch (error) {\n        console.warn(`Failed to convert coordinates [${x}, ${y}]:`, error);\n        return coords; // Return original if conversion fails\n      }\n      \n    default:\n      console.warn(`Unknown coordinate system for [${x}, ${y}]`);\n      return coords;\n  }\n};\n\n/**\n * Validate and enhance feature locations\n */\nconst validateFeatureLocation = (feature, category) => {\n  const geometry = feature.geometry;\n  const properties = feature.properties;\n  \n  if (!geometry || !geometry.coordinates) {\n    console.warn(`Feature missing coordinates:`, properties);\n    return false;\n  }\n  \n  // For point features, validate coordinates are in Victoria\n  if (geometry.type === 'Point') {\n    const [lon, lat] = geometry.coordinates;\n    \n    if (!isValidVictoriaCoordinates(lat, lon)) {\n      console.warn(`Feature coordinates outside Victoria: [${lat}, ${lon}]`, properties);\n      return false;\n    }\n  }\n  \n  // Category-specific validation\n  switch (category) {\n    case 'ambulance':\n      return validateAmbulanceFeature(feature);\n    case 'police':\n      return validatePoliceFeature(feature);\n    default:\n      return true;\n  }\n};\n\nconst isValidVictoriaCoordinates = (lat, lon) => {\n  return (\n    lat >= -39.5 && lat <= -33.5 &&\n    lon >= 140.5 && lon <= 150.5\n  );\n};\n\nconst validateAmbulanceFeature = (feature) => {\n  const props = feature.properties;\n  \n  // Must be in Victoria\n  if (props.facility_state?.toLowerCase() !== 'victoria') {\n    return false;\n  }\n  \n  // Must have facility name\n  if (!props.facility_name || !props.facility_name.trim()) {\n    return false;\n  }\n  \n  // Must have valid coordinates in properties (backup)\n  const lat = parseFloat(props.facility_lat);\n  const lon = parseFloat(props.facility_long);\n  \n  if (isNaN(lat) || isNaN(lon)) {\n    return false;\n  }\n  \n  return isValidVictoriaCoordinates(lat, lon);\n};\n\nconst validatePoliceFeature = (feature) => {\n  const props = feature.properties;\n  \n  // Must have place name\n  if (!props.place_name || !props.place_name.trim()) {\n    return false;\n  }\n  \n  // Coordinates already validated by geometry check\n  return true;\n};\n```\n\n## ðŸ› ï¸ Data Preparation Tools\n\n### **CFA Coordinate Enhancement Script**\n\nExample of how geocoding is used for data preparation:\n\n```bash\n# CFA Coordinate Enhancement Guide\n# From scripts/CFA_COORDINATE_GUIDE.md\n\n# 1. Install required dependencies\npip install -r scripts/requirements-geocoding.txt\n\n# 2. Run coordinate enhancement script\npython scripts/add_cfa_coordinates.py\n\n# 3. Script process:\n# - Reads cfabld.json (CFA brigade data)\n# - Extracts address and suburb from each brigade\n# - Uses Nominatim to geocode addresses\n# - Respects 1-second rate limit\n# - Outputs enhanced data to cfabld_with_coords.json\n# - Logs errors to cfabld_with_coords_errors.txt\n\n# 4. Sample output:\nUsing OpenStreetMap Nominatim for geocoding (free service)\nRate limit: 1 request per second (respects Nominatim usage policy)\n\nProcessing 1200+ CFA brigades...\nThis may take several minutes due to geocoding rate limits...\n\nBallarat Fire Brigade\n  Address: 123 Main Street, Ballarat\n  âœ“ Geocoded: -37.5622, 143.8503\n\nBendigo Fire Brigade  \n  Address: 456 High Street, Bendigo\n  âœ“ Geocoded: -36.7570, 144.2794\n\nProgress: 10.0% (120/1200)\n...\n\nGeocoding complete: 1156/1200 successful (96.3%)\nResults saved to cfabld_with_coords.json\nErrors logged to cfabld_with_coords_errors.txt\n```\n\n### **Geocoding Quality Assurance**\n\n```python\n# Quality assurance for geocoded data\nclass GeocodingQA:\n    \"\"\"\n    Quality assurance tools for geocoded data.\n    \"\"\"\n    \n    def __init__(self):\n        self.victoria_bounds = {\n            'lat_min': -39.5,\n            'lat_max': -33.5,\n            'lon_min': 140.5,\n            'lon_max': 150.5\n        }\n    \n    def validate_coordinates(self, lat: float, lon: float) -> dict:\n        \"\"\"\n        Validate that coordinates are reasonable for Victoria.\n        \"\"\"\n        issues = []\n        \n        # Check bounds\n        if not (self.victoria_bounds['lat_min'] <= lat <= self.victoria_bounds['lat_max']):\n            issues.append(f\"Latitude {lat} outside Victoria bounds\")\n        \n        if not (self.victoria_bounds['lon_min'] <= lon <= self.victoria_bounds['lon_max']):\n            issues.append(f\"Longitude {lon} outside Victoria bounds\")\n        \n        # Check for common coordinate swap\n        if abs(lat) < abs(lon) and abs(lat) < 50:\n            issues.append(\"Possible lat/lon coordinate swap\")\n        \n        # Check for suspiciously precise coordinates (possible fake data)\n        if lat == round(lat) and lon == round(lon):\n            issues.append(\"Suspiciously round coordinates\")\n        \n        return {\n            'valid': len(issues) == 0,\n            'issues': issues,\n            'coordinates': {'lat': lat, 'lon': lon}\n        }\n    \n    def analyze_geocoding_results(self, results: dict) -> dict:\n        \"\"\"\n        Analyze geocoding results for quality metrics.\n        \"\"\"\n        stats = {\n            'total': len(results),\n            'successful': 0,\n            'failed': 0,\n            'invalid_coordinates': 0,\n            'coordinate_issues': [],\n            'common_errors': {}\n        }\n        \n        for item_id, result in results.items():\n            if result['status'] == 'success':\n                stats['successful'] += 1\n                \n                # Validate coordinates\n                validation = self.validate_coordinates(\n                    result['latitude'], \n                    result['longitude']\n                )\n                \n                if not validation['valid']:\n                    stats['invalid_coordinates'] += 1\n                    stats['coordinate_issues'].append({\n                        'id': item_id,\n                        'coordinates': validation['coordinates'],\n                        'issues': validation['issues']\n                    })\n            else:\n                stats['failed'] += 1\n                \n                # Track common errors\n                error = result.get('error', 'Unknown error')\n                stats['common_errors'][error] = stats['common_errors'].get(error, 0) + 1\n        \n        # Calculate success rate\n        stats['success_rate'] = (stats['successful'] / stats['total']) * 100 if stats['total'] > 0 else 0\n        \n        return stats\n    \n    def generate_qa_report(self, results: dict) -> str:\n        \"\"\"\n        Generate a quality assurance report.\n        \"\"\"\n        stats = self.analyze_geocoding_results(results)\n        \n        report = f\"\"\"\n# Geocoding Quality Assurance Report\n\n## Summary\n- Total addresses processed: {stats['total']}\n- Successfully geocoded: {stats['successful']} ({stats['success_rate']:.1f}%)\n- Failed to geocode: {stats['failed']}\n- Invalid coordinates: {stats['invalid_coordinates']}\n\n## Success Rate\n{self._create_progress_bar(stats['success_rate'])}\n\n## Common Errors\n\"\"\"\n        \n        for error, count in sorted(stats['common_errors'].items(), key=lambda x: x[1], reverse=True):\n            report += f\"- {error}: {count} occurrences\\n\"\n        \n        if stats['coordinate_issues']:\n            report += \"\\n## Coordinate Issues\\n\"\n            for issue in stats['coordinate_issues'][:10]:  # Show first 10\n                report += f\"- {issue['id']}: {', '.join(issue['issues'])}\\n\"\n            \n            if len(stats['coordinate_issues']) > 10:\n                report += f\"... and {len(stats['coordinate_issues']) - 10} more\\n\"\n        \n        return report\n    \n    def _create_progress_bar(self, percentage: float, width: int = 50) -> str:\n        \"\"\"\n        Create a simple ASCII progress bar.\n        \"\"\"\n        filled = int((percentage / 100) * width)\n        bar = 'â–ˆ' * filled + 'â–‘' * (width - filled)\n        return f\"[{bar}] {percentage:.1f}%\"\n```\n\n## ðŸ”— Related Documentation\n\n- **[API Overview](README.md)** - Complete API reference\n- **[Data Formats](data-formats.md)** - GeoJSON coordinate specifications\n- **[Examples](examples.md)** - Coordinate conversion examples\n- **[Error Handling](error-handling.md)** - Geocoding error recovery patterns\n\n---\n\n**This completes the comprehensive API documentation for WeeWoo Map Friend.** For additional implementation details, see the [complete examples](examples.md) and [development guide](../development/README.md).